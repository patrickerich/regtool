// Register block: {{ name }}
// Generated by regtool

module ${name}_reg_block #(
    parameter int AW = ${reg_aw},
    parameter int DW = ${reg_dw}
) (
    input                    clk_i,
    input                    rst_ni,
    
    // Register interface
    input                    reg_we_i,
    input                    reg_re_i,
    input        [AW-1:0]    reg_addr_i,
    input        [DW-1:0]    reg_wdata_i,
    output logic [DW-1:0]    reg_rdata_o,
    output logic             reg_error_o,
    
    // Memory interfaces
% for memory in memories:
    // ${memory.name} interface
    output logic            ${memory.name.lower()}_cs_o,
    output logic            ${memory.name.lower()}_we_o,
    output logic [AW-1:0]   ${memory.name.lower()}_addr_o,
    output logic [${memory.width}-1:0] ${memory.name.lower()}_wdata_o,
    input  logic [${memory.width}-1:0] ${memory.name.lower()}_rdata_i,
% endfor
);

    // Memory region decode
% for memory in memories:
    assign ${memory.name.lower()}_cs_o = (reg_addr_i >= 'h${"%x" % memory.offset} && 
                                         reg_addr_i < 'h${"%x" % (memory.offset + memory.size * (memory.width//8))});
    assign ${memory.name.lower()}_we_o = ${memory.name.lower()}_cs_o && reg_we_i;
    assign ${memory.name.lower()}_addr_o = reg_addr_i - 'h${"%x" % memory.offset};
    assign ${memory.name.lower()}_wdata_o = reg_wdata_i;
% endfor
{% for register in registers %}
    // {{ register.name }} Register
    logic [DW-1:0] {{ register.name|lower }}_q;
    {% if register.swaccess == "rw" %}
    logic {{ register.name|lower }}_we;
    {% endif %}
    
{% endfor %}

    // Register write enables
{% for register in registers %}
    {% if register.swaccess == "rw" %}
    assign {{ register.name|lower }}_we = reg_we_i && (reg_addr_i == 'h{{ "%x"|format(register.offset) }});
    {% endif %}
{% endfor %}

    // Sequential write logic
% for register in registers:
    % if register.swaccess in ['rw', 'w1c', 'w1s']:
    always_ff @(posedge clk_i or negedge rst_ni) begin
        if (!rst_ni) begin
            ${register.name.lower()}_q <= '0;
        end else if (${register.name.lower()}_we) begin
        % if register.swaccess == 'w1c':
            ${register.name.lower()}_q <= ~reg_wdata_i & ${register.name.lower()}_q;
        % elif register.swaccess == 'w1s':
            ${register.name.lower()}_q <= reg_wdata_i | ${register.name.lower()}_q;
        % else:
            ${register.name.lower()}_q <= reg_wdata_i;
        % endif
        end
    end
    % endif
% endfor

    // Register read logic
    always_comb begin
        reg_rdata_o = '0;
        reg_error_o = 1'b0;
        
        case (reg_addr_i)
{% for register in registers %}
            'h{{ "%x"|format(register.offset) }}: reg_rdata_o = {{ register.name|lower }}_q;
{% endfor %}
            default: reg_error_o = 1'b1;
        endcase
    end

endmodule